```sql
`EXPLAIN ANALYSE`的执行结果
```
```sql
Seq Scan on hisp_pop
  (cost=0.00..33.48 rows=1 width=16)
  (actual time=0.205..0.339 rows=1 loops=1)
  Filter: ((tract_id)::text='2502010103'::text)
  Rows Removed by Filter:1477
Total runtime:0.360
```
集合所有的执行计划都会包含多个步骤，每一步骤又可以包含若干个子步骤。每一步骤会有一个估算的执行时间范围，看起来像这样：`cost=0.00..33.48`，如示例`9-2`所示。其中第一个数字`0.00`是估算的该步骤起始执行时间，第二个数字`33.84`是估算的该步骤总执行时间。起始执行时间点之前会执行一些后续计算的准备工作，而读取数据、索引扫描、夺表数据关联整合等动作都是在其实执行时间点之后发生的。如果执行方式未全表扫描，那么其其实执行时间点为0，因为这种场景下只是简单地立即开始扫描全表数据，没有什么预备动作。

请注意，估算的执行时间（cost）的单位并不是真实的时间单位，而是取决于硬件环境以及规划器的执行时间单位常数。因此，`cost`值金鱼有相对意义，**可用于比较同一台物理服务器上多个执行计划之间的效率**。规划器的任务就是要选择出整体`cost`最低的一个执行计划。

通过示例`9-2`中的执行计划可以看到规划器选择了全表扫描策略，因为没有任何索引可用。小输出的`Rows Removed by Filter:1477`是扫描过程中排除掉的不符合条件的记录数。

在`PostgreSQL 9.4`版本中，`EXPLAIN`输出的执行计划中区分了分析执行计划的时间和真正的执行时间，并将两者分开单列。

```sql
Planning time: 0.095ms
Execution time: 0.381ms
```

我们将主键重新建立起来

```sql
ALTER TABLE census.hisp_pop ADD CONSTRAINT hisp_pop_pkey PRIMARY KEY(tract_id)
```

```sql
Index Scan using idx_hisp_pop_tract_id_pat on hisp_pop
(cost=0.28..8.29) (actual time=0.081..0.019 rows loops=1)
Planning time:0.110
Execution time:0.046
```

此场景下规划期判定使用索引会比全表扫描效更高，因此在执行假话中使用了索引扫描策咯。估算的执行时间从`33.48`降到了`8.29`。起始执行时间也不再是`0`，因为规划期需要先扫描索引，燃火才嫩古巴命中记录从磁盘取出来。你可以看到规划期不再需要扫描`1477`条记录，这极大地降低了执行成本。

最终执行的步骤显示时总是排在最前，其中个记录的估算时间和真实时间就是其所有子步骤相应项目之和。子步骤在显示时是按照层级向右逐级缩进的。

`PostgreSQL`有执行计划缓存功能，所以如果我们再次执行此语句，或者执行一个可以共享缓存下来的执行计划的类似语句，那么执行计划的分析时间就会大大减少。
