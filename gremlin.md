Azure Cosmos DB supports `Apache Tinkerpop's` graph traversal language, known as `Gremlin`. 

![Sample database showing persons, devices, and interests](https://docs.microsoft.com/en-us/azure/cosmos-db/media/gremlin-support/sample-graph.png)

This graph has the following vertex types(called "label" in Gremlin)

1. People: The graph has three people, Robin, Thomas, and Ben

2. Interests: Their interests, in this example, the game of Football

3. Devices: The devices that people use

4. Operating Systems: The operating systems that the devices run on

   

The following Gremlin statement inserts the "Thomas" vertex into the graph:

```
g.addV('person').property('id', 'thomas.1').property('firstName', 'Thomas').property('lastname', 'Andersen').property('age', 44)
```

this statement inserts a "knows" edge between Thomas and Robin

```
g.V('thomas.1').addE('knows').to(g.V('robin.1'))
```

The following query returns the "person" vertices in descending order of their first names:

```
g.V().hasLabel('person').order().by('firstName', decr)
```

TinkerPop is a standard that covers a wide range of graph technologies. Therefore, it has standard terminology to describe what features are provided by a graph provider. 

Azure Cosmos DB uses the GraphSON format when returning results from Gremlin operations. GraphSON is the Gremlin standard format for representing vertices, edges, and properties(single and multi-valued properties) using JSON.

```json
  {
    "id": "a7111ba7-0ea1-43c9-b6b2-efc5e3aea4c0",
    "label": "person",
    "type": "vertex",
    "outE": {
      "knows": [
        {
          "id": "3ee53a60-c561-4c5e-9a9f-9c7924bc9aef",
          "inV": "04779300-1c8e-489d-9493-50fd1325a658"
        },
        {
          "id": "21984248-ee9e-43a8-a7f6-30642bc14609",
          "inV": "a8e3e741-2ef7-4c01-b7c8-199f8e43e3bc"
        }
      ]
    },
    "properties": {
      "firstName": [
        {
          "value": "Thomas"
        }
      ],
      "lastName": [
        {
          "value": "Andersen"
        }
      ],
      "age": [
        {
          "value": 45
        }
      ]
    }
  }
```



 The Azure Cosmos DB Gremlin API is used to store and operate on graph 
data. Gremlin API supports modeling Graph data and provides APIs to 
traverse through the graph data.

```
gremlin> graph = TinkerFactory.createModern()
==>tinkergraph[vertices:6 edges:6]
gremlin> g = graph.traversal()
==>graphtraversalsource[tinkergraph[vertices:6 edges:6], standard]
```

The first command creates a `Graph` instance named `graph`, which thus provides a reference to the data you  want Gremlin to traverse. Unfortunately, just having `graph` doesn't provide Gremlin enough context to do his job. You also need something called a `TraversalSource`, which is generated by the second command. The `TraversalSource` provides additional information to Gremlin(such as traversal strategies to apply and the traversal engine to use) which provides him guidance on how to execute his trip around the `Graph`

```gremlin
gremlin> g.V() //1\
==>v[1]
==>v[2]
==>v[3]
==>v[4]
==>v[5]
==>v[6]
gremlin> g.V(1) //2\
==>v[1]
gremlin> g.V(1).values('name') //3\
==>marko
gremlin> g.V(1).outE('knows') //4\
==>e[7][1-knows->2]
==>e[8][1-knows->4]
gremlin> g.V(1).outE('knows').inV().values('name') //5\
==>vadas
==>josh
gremlin> g.V(1).out('knows').values('name') //6\
==>vadas
==>josh
gremlin> g.V(1).out('knows').has('age', gt(30)).values('name') //7\
==>josh
```

1. Get all the vertices in the `Graph`
2. Get a vertex with the unique identifier of "1"
3. Get the value of the `name` property on vertex with the unique identifier of "1".
4. Get the edges with the label "knows" for the vertex with the unique identifier of "1"
5. Get the names of the people that the vertex with the unique identifier of "1" "knows"
6. Note that when on uses `outE().inV()` as shown in the previous command, this can be shortened to just `out()` (similar to `inE().outV()` and `in()` for incoming edges).
7. Get the names of the people vertex "1" knows who are over the age of 30.

There are a number of important things to consider in the above code. First, recall that `id` is "reserved" for special usage in TinkerPop and is a member of the   enum, `T`.  Those "keys" supplied to the creation method are statically imported to the console, which allows you to access them without having to specify their owning enum. 

"What software has Marko created?"

Let's start with finding "marko". This operation is a filtering step as it searches the full set of vertices to match

```
g.V().has('name','marko')
```

This bit of Gremlin can be improved and made more idiomatically pleasing by including the vertex label as part of the filter to ensure that the "name" property key refers to a "person" vertex

```
g.V().has('person', 'name', 'marko')
```

is same as

```
g.V().hasLabel('person').has('name', 'marko')
```

Hence, any traversal thatâ€™s going to be used in production code should
also specify the vertex label to prevent the query engine from searching every index for the provided property value.

```
gremlin> g.V().has('person', 'name', 'marko').outE('created').inV()
==>v[3]
```

is same as 

```
g.V().has('person','name','marko').out('created')
```

You can therefore ask Gremlin to extract the value of the "name" property as follows:

```
g.V().has('person', 'name', 'marko') .out('created').values('name')
```

What if we wanted Gremlin to find the "age" values of both "vadas" and "marko"? In this case we could use the `within` comparator with `has()` as follows:

```
g.V().has('person','name',within('vadas','marko')).values('age').mean()
```

To find out who "created" that "software", we need to have Gremlin traverse back in along the "created" edges to find the "person" vertices tied to it.

```
gremlin> g.V().has('person', 'name', 'marko').out('created').in('created').values('name')
==>marko
==>josh
==>peter
```

excluding `marko`

```
 g.V().has('person','name','marko').as('exclude').
           out('created').in('created').
           where(neq('exclude')).
           values('name')
```

We made two additions to the traversal to make it exclude "marko" from the results. First, we added the `as()` step. The `as()` step is not really a "step", but a "step modulator" - something that adds features to a step or the traversal. Here the `as('exclude')` labels the `has()` step with the name "exclude" and all values that pass through that step are held in that label for later use. In this case, the "marko" vertex is the only vertex to pass through that point, so it is held in "exclude".

The other addition that was made was the `where()` step which is a filter step like `has()`. The `where()` is positioned after `in()` step that has "person" vertices, which means that the `where()` filter is occurring  on the list of "marko" collaborators. The `where()` specifies that the "person" vertices passing throught it should not equal `neq()` the content of the `exclude` label.
