## 访问外部硬件有两个方式

1. 将某个外设的内存映射到一定范围的地址空间中， CPU通过地址总线访问该内存区域时会落到外设的内存中，这种映射让CPU访问外设的内存就如同访问主板上的物理内存一样。

2. 外设通过IO接口与CPU通信，CPU访问外设，就是访问IO接口，由IO接口将信息传递给另一端的外设，也就是说，CPU从来不知道有这些设备的存在，它只知道自己操作的IO接口。
 
 编译器提供了一套库函数，库函数又有封装的系统调用，这样的代码称之为运行库。C语言的运行库称为**C运行库**，就是所谓的CRT（C Runtime Library)

应用程序加上操作系统提供功能才算是完整的程序。用户进程陷入内核态是指：由于内部或外部中断发生，当前进程被暂时中止执行，其下上文被内的的终端程序保存以来后，开始执行一段内核的代码。

当应用程序陷入内核之后，他自己以及下CPU了，以后发生的事，应用程序完全不知道，它的上下文环境已经被保存到自己的0特权级栈中了，那时在CPU上运行的程序已经是内核程序了。

对于Linux系统来说，直接嵌入会变代码`int 80`即可执行系统调用。

如果把软件分层的话，最外圈是应用程序，里面是操作系统。应用程序处于特权级3，操作系统处于特权级0。当用户程序欲访问系统资源时（无论是硬件，还是内核数据结构），它需要进行系统调用。这样CPU进入了内核态，也称管态。

CPU采用“段基址 + 段内偏移地址”的形式访问内存，就需要专门提供段基址寄存器。程序中需要用到哪块内存，只要先加载合适的段到段基址寄存器中，再给出相对于该段基址的便宜地址便可，CPU中的地址单元会将这两个地址相加后的结果用于内存访问，送上地址总线。

举个例子，假设段基址为`0xC00`，要想访问物理内存`0xC01`，就要将用`0xC01:0x00`的方式来访问。同样，若要访问物理内存`0xC04`，段基址和段内偏移的组合可以是`0xC01:0x03`、`0xC02:0x02`、`0xC00:0xC04`等等，总之想要访问某个物理地址，只要凑出合适的段基地址和段内偏移地址，其和为该物理地址就行了。

说了那么多，我想告诉你的是只要程序分了段，吧整个段平移到任何位置后，段内的地址相对于段基址是不变的，无论段基址是多少，只要给出段内偏移地址，CPU就能访问正确的指令。于是加载用户程序时，因为程序中用的是段内偏移地址，相对于新的段基址，该偏移地址出的内存内容还是一样的。
