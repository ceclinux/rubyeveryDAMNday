bochs config
```
megs: 32
romimage: file=/usr/share/bochs/BIOS-bochs-latest
vgaromimage: file=/usr/share/vgabios/vgabios.bin

ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
ata0-master: type=disk, path="hd60M.img", mode=flat, cylinders=121, heads=16, spt=63


boot: disk

log: bochs.out
mouse: enabled=0
keyboard_mapping: enabled=1, map=x11-pc-us.map
```

create hard disk
```
bximage -hd -mode="flat" -size=60 -q hd60M.img
```

所谓载入内存，大概分为两部分：

1. 程序被加载器（软件或硬件）加载到某个硬件区域
2. CPU的cs:ip寄存器被指向这个程序的起始地址

BIOS的主要工作是检测、初始化硬件，怎么初始化？硬件自己提供了一些初始化的功能调用，BIOS直接调用就好了。BIOS还做了一件伟大的事情，建立了**中断向量表**。这样就可以通过”int 中断号“来实现相关的硬件调用，当然BIOS建立的这些功能就是对硬件的IO操作，也就是输入输出。但有时就64KB大小的空间，不可能把所有硬件的IO操作实现的面面俱到，而且也必要实现这么多，毕竟是在实模式下，对硬件支持的再丰富也是白搭，所以挑一些重要的、保证计算机能运行的那些硬件的基本操作，就行了。

地址总线宽度决定过了可以访问的内存空间的大小，如16位机的地址总线为20位，其地址范围是1MB，32位地址总线宽度是32位，其地址范围是4GB。但以上的地址范围指的是计算机在寻址上可以达到的疆域。可是人家并没有说要寻哪里，就拿16位机来说，并没有说这16位的寻址范围必须得是物理内存，难道人家的20位地址总线就得认这一亩三分地吗？完全不是。

归根结底的原因是这样的：在计算机中，并不是只有咱们插在主板上的内存条需要通过地址总线访问，某些地方给了显存，某些小地方给了硬盘控制器等。留够了之后，其余地方留给GUI。所有4GB的内存，在电脑里只显示3.8G

总之，表示地址的那串数字是地址总线的输入，相当于其参数，和内存条没关系。CPU能够访问一个地址，这是地址总线给做的映射，相当于给该地址分配了一个存储单元 ，二该存储单元要么落在某个外设的内存中，要么落在了物理内存条上。

在开机的一瞬间，也就是通电的一瞬间，CPU的`cs:ip`寄存器被强制初始化为`0xF000:0xFFF0`。由于开机的时候处于实模式，再重复一遍加深印象，在实模式下的段基址要乘以16，也就是左移4位，于是`0xF000:0xFFF0`的等效地址将是`0xFFFF0`。此地址就是`BIOS`的入口地址。

BIOS最后一项工作是检验启动盘中位于0盘0道1扇区的内容。如果此扇区末尾的两个字节分别是魔数`0x55`和`0xaa`，BIOS便认为此扇区确实存在可执行的程序（此程序便是MBR），便加载到物理地址`0x7c00`，随后跳转到此地址，继续执行。

$和$$是编译器NASM预留的关键字，用来表示当前行和本section的地址，起到了标号的作用，它是`nasm`提供的，并不是CPU原生支持的，相当于伪指令一样，对CPU是假的。

**伪指令**是编译器为了开发人员写代码方便而提供的一些符号，这些符号在编译时，会由编译器转换为CPU可识别的东西，如指令或地址等。如

```assembly
code_start:
  mov ax, 0
```

`code_start`这个标号被`nasm`认为是一个地址，此指令便是`mov ax, 0`这条指令所在的地址，即其机器指令机器码的存放的内存位置是`code_start`。`code_start`只是个标记，CPU并不认识，所以`nasm`会为其安排的地址来替换标号`code_start`，到了CPU手中，已经被替换成有意义的数字形式的地址了。

如果上面的例子改为

```assembly
code_start
    jmp $
```

$$指代本`section`的起始地址，此地址同样是编译器给安排的。

`section`也称为节、段，顾名思义，是程序中的一小段，形象一点说，就是用`section`这个关键字在程序中圈出一块地，并向编译器宣称，这块地我要做些规划，至于我要干些什么您就不用担心了，编译时请您合理安排。

比如一下代码

```assembly
section data
  var dd 0
section code
  jmp start
```

编译器一看这两个`section`，`data`中定义的是变量，`code`中是代码，于是把这两个`section`的内容分别归入最终的数据段和代码段。

有时候`nasm`并不会完全听您的，如改为下面的例子

```assembly
section data_a
  var dd 0
section code
  jmp start
section data_b
  var dd 1
```

随后人为定义了三个`section`，但`nasm`发现了`data_a`和`data_b`这两个`section`完全能够合并到一起，于是编译阶段会被合理的安排在一起。

`section`是伪指令，`CPU`运行程序是不需要这个东西的，这个只是给程序员规划程序用的。

`bin`是纯二进制。纯二进制就是不掺杂其他的东西，直接给CPU就能使用，也就是可执行文件中什么样，内存中就什么样。我们平时所说的`elf`或者`pe`格式的二进制可执行文件，那里面有好多和指令无关的东西，里面有很多程序的内存布局、位置等信息，这是给操作系统的程序加载器用的，是属于操作系统规划的范畴了。

```assembly
SECTION MBR vstart=0x7c00
    mov ax, cs
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov fs, ax
    mov sp,  0x7c00

    mov ax, 0x600
    mov bx, 0x700
    mov cx, 0
    mov dx, 0x184f

    int 0x10

    mov ah, 3
    mov bh, 0

    int 0x10

    mov ax, message
    mov bp, ax

    mov cx, 5
    mov ax, 0x1301

    mov bx, 0x2

    int 0x10

    jmp $

    message db "1 MBR"
    times 510-($-$$) db 0
    db 0x55, 0xaa
```

`0x10`中断事最为强大的BIOS中断了，调用的方法是把功能号送入`ah`寄存器，随后执行`int 0x10`即可。

第三行的`vstart=0x7c00`表示本程序在编译时，告诉编译器，把我们的起始地址编译为`0x7c00`。

第4~8行是用`cs`寄存器的值去初始化其他寄存器。由于`BIOS`是通过
`jmp 0:0x7c00`跳转到mbr的，故`cs`此时为0，对于ds,es,fs,
gs这类的`sreg`，CPU不能直接给他们赋值，没有从立即数到段寄存器的电路实现，只有通过其他寄存器来中转，这里我们是通过`ax`来中转。

第9行是初始化栈指针，在CPU上运行的程序得遵从CPU的规则，`mbr`也是程序，是程序就要用到栈。目前`0x7c00`一下暂时是安全的区域，就把它当作栈来使用。

第`11-28`行是清屏。因为在`BIOS`中作中，会有一些输出，如检测硬件的结果信息。为了让大家看清楚我们在`MBR`中的输出字符串，故先把BIOS的输出清掉，这里演示
的是中断`0x10`的用法。

第`30-35`行是做打印前的工作，先获取光标的位置，目的是比秒打印字符的混乱，覆盖别人的输出。其实这个防君子不防小人的做法，万一别人不在光标处打印，自己打印的东西同样会被
别人覆盖。字符打印的位置，不一定要在光标处，字符的位置只和显存中的地址有关，和光标是没关系的，这只是人为的加了约束。

这里还用到了叶的概念，您看第33行，往`bh`寄存器中写入了0，这是告诉`BIOS`例程，我要获取第0页当前的光标，什么是页呢？

显示器有很多模式，如图形模式、文本模式等，在文本模式中，又可以工作于`80*25`和`40*25`等显示方式，默认情况下，所有个人计算机的显卡在加电后都将自己重置成`80*25`这种显示模式，由于一个字符要用两个字节表示，故显示一屏需要4000字节，这一屏就称为1夜，0页是默认页。

第38~52行是往光标处打印字符，说一下第48行的`mov ax, 0x1301`，13对应的是`ah`寄存器，这是调用`0x13`号子功能。`01`对应的是`al`寄存器，表示的是写字符的方式，al=1时，显示字符串，并且光标跟随到新位置。

`message db "1 MBR"`是定义打印的字符串。

第58行的`$$`是本`section`的起始地址，上面说过了`$`是本行所在的地址，故`$-$$`是本行到本`section`的偏移量。由于`mbr`的最后两个字节是固定的内容，分别是`0x55`和`0xaa`，要预留出两个字符，故扇区前`512-510`字节要填满，那到底呀多少字节才能填满次山区了。用510字节减去上面通过`$-$$`得到的偏移量。其结果就是本扇区的剩余量。由此可见第50行的`times 510-$($-$$) do 0`是在用0将本扇区的剩余空间填充。

```nasm
00000000 B80000 mov ax,0x0 
00000003 8ED8 mov ds,ax 
00000005 A10D00 mov ax,[0xd] 
00000008 B80800 mov ax,0x8 
0000000B EBFB jmp short 0x8 
0000000D 99 cwd 
0000000E 00 db 0x00
```

源码经编译之后都会变成我们不认识的东西，这个东西是机器码，还是数据，取决于源码中相应的内容。例如第二行`mov ds, ax`，明显是指令，被编译器处理之后，其所在地址出的内容就是机器码`8ED8`，长得完全不像是`mov ds, ax`。

而源码`var dw 0x99`，明显就是数据定义，查看内容列，它经编译之后，变成了99、00，因为`dw`是定义一个字，双字节，并且`x86`是小端字节序，低位的`99`在低地址，高位的`00`在高地址，所以`D`处内容是`99`，地址`E`处的内容是`00`。

`$$`表示所在的`section`的起始地址，由于这6行代码中没有定义`section`，故`nasm`默认把全体文件当成一个大的`section`。

第二行涉及真指令，不牵涉符号转换，所以反汇编后的代码同源码一致。

第三行引用了`var`变量的值，`[]`符号是取所在地址处的内容。在相应的反汇编代码中，相应的第三行中`var`这个符号地址被编译器替换成`0xd`。

第四行源码是`label: mov ax,$`，`label`是个符号，代表指令`mov ax, $`所在地址。`$`是个隐式的标号，表示当前地址。按理说这两个标号值应该是一致的，验证一下，查看下反汇编代码列的第四行，`$`被替换为`0x8`，即本行的`mov`指令地址是`0x8`。

顺便说一句，CPU不去判断给他的内容是指令，还是一般数据，他也分不清楚。CPU执行命令是顺序向下执行的，所以若没有第5行的`jmp`形成子循环，CPU执行到第六行时，会把`var`变量的值99当成指令，是否会报错还不得而知，这得看它得数是否恰好能成为个指令。这里就敲好能称为扩展指令CWD。

```nasm
section code
mov ax,$$
mov ax,section.data.start
mov ax,[var1]
mov ax,[var2]
label: jmp label

section data
var1 dd 0x4

var2 dw 0x99
```

```nasm
00000000  B80000            mov ax,0x0
00000003  B81000            mov ax,0x10
00000006  A11000            mov ax,[0x10]
00000009  A11400            mov ax,[0x14]
0000000C  EBFE              jmp short 0xc
0000000E  0000              add [bx+si],al
00000010  0400              add al,0x0
00000012  0000              add [bx+si],al
00000014  99                cwd
00000015  00                db 0x00
```

第1行和第8行为空，并没有产生相应地址或机器指令，这就是`section`为伪指令的原因。

第3行中用到了`section.data.start`，其用法是`section.节名.start`，这里是获得名为`data`的`section`在本文件中的正式偏移，即起始地址，是`nasm`提供的伪指令。查看“反汇编代码”列的第一行，编译后已经被替换为`0x10`，说明定义的数据`section`起始地址为`0x10`。可见，定义的`section`，其起始地址是从上一个数据的地址延续下来的。

由于`var1`是数据`section`的首个数据，其地址必然是和数据`section`一致。故对比下“源码”列和“反汇编代码”列的第四行，`var1`的地址确实被替换成`0x10`。

故关键字`section`并没有对程序中的地址产生任何影响。

```nasm
00000000  B80007            mov ax,0x700
00000003  B80000            mov ax,0x0
00000006  B81400            mov ax,0x14
00000009  B80907            mov ax,0x709
0000000C  A10009            mov ax,[0x900]
0000000F  A10409            mov ax,[0x904]
00000012  EBFE              jmp short 0x12
00000014  0400              add al,0x0
00000016  0000              add [bx+si],al
00000018  99                cwd
00000019  0000              add [bx+si],al
0000001B  00                db 0x00
```

源码第二行的$$在编译后被替换为`vstart`的值`0x7c00`，可见，`$$`以该节的虚拟地址为主，若该节未用`vstart`来制定则以在文件中的起始地址为主。

第3行和第4行的源码和相应反汇编代码表明“code.节名.start”是节在真个程序中的地址，即相对于文件开头的偏移量。

第五行的`$`在文件中的地址是`0x9`，经编译后变成了`0x7c09`，类似于重定位。

第6，7行中引用的变量`var1`和`var2`属于`data`节，由于该节有`vstar=0x900`，所以该节中的`var1`地址是`0x900`，`var2`是`0x900 + var1`的内存空间`0x904`

`varstart=xxxx`和`org xxxx`这两个关键字是同一功能，但很多同学混淆其意义。它们并不是告诉编译器程序加载到地址`xxxx`，这似乎一听，好像是编译器有记载器的功能了，“加载”并不是它的工作，这是加载器的工作，编译器只会规划代码。

编译器以相对于文件开头偏移来编址的好处是利于重定位。整个文件加载到某个地址之后，可以以这个地址为段基址，文件内数据地址是以`0`开始算的，所以它们直接就可以用作段内偏移地址了。

为什么`mbr`能够运行正常？

`mbr`用`vstart=0x7c00`来修饰的原因，是因为开发人员知道`mbr`要被加载器（BIOS）加载到物理地址`0x7c00`，`mbr`后续的物理地址都是`0x7c00`。另外，因为BIOS进入`mbr`是通过`jmp 0: 7c00`来实现的，所以`mbr`个数据编译出来的地址（大于等于`0x7c00`）实际上都成了偏移地址。这样“0*16：偏移地址 0x7c00+”来访问被加载到的`0x7c00`的`mbr`是正确无误的，所以说，用`vstart`的时机是：我预先知道我的程序将来被加载到某处。程序址由加载到非0地址时`vstart`才是有用的，程序默认起始地址是0。

实模式是指8086CPU的寻址模式、寄存器大小、指令用法等，是用来反应`CPU`在该环境下如果和工作的概念。所以想了解实在模式这种丑行的概念，主要就是了解在实模式下CPU能做什么。

CPU大体上可以划分为3个部分，它们是控制单元、运算单元、存储单元。

控制单元是CPU的控制中心，`CPU`需要经过它的帮忙才知道自己下一步要做什么。而控制单元大致由指令寄存器`IR`、指令译码器`ID`、操作控制器`OC`组成。程序被加载到内存后，也就是指令这是都在内存中了，指令指针寄存器IP指向内存中下一条待执行指令的地址。控制单元根据`IP`寄存器的指向，将位于内存中的指令逐个装载到指令寄存器中，但它还是不知道这些指令是什么，在它眼里的`0101`串此时还没有实际意义。然后指令译码器将位于指令寄存器中的指令按照指令格式来解码，分析处操作码是什么，操作数在哪里之类的。

SRAM是比DRAM更为昂贵，但更为快速、非常低功耗（特别是在空闲状态）。因此SRAM首选用于带宽要求高，或者功耗要求低，或者二者兼而有之。SRAM比起DRAM更为容易控制，也更是随机访问。由于复杂的内部结构，SRAM比DRAM的占用面积更大，因而不适合用于更高储存密度低成本的应用，如PC内存。

SRAM用于PC、工作站、路由器以及外设：内部的CPU高速缓存，外部的突发模式使用的SRAM缓存，硬盘缓冲区，路由器缓冲区，等等。LCD显示器或者打印机也通常用SRAM来缓存数据。SRAM做的小型缓冲区也常见于CDROM与CDRW的驱动器中，通常为256 KiB或者更多，用来缓冲音轨数据。线缆调制解调器及类似的连接于计算机的设备也使用了SRAM。

寄存器可以分为两大类，程序员可以使用的寄存器称为可见寄存器，如通用寄存器、段寄存器。程序不可见的寄存器是指程序员不可使用，也无法访问到它们，系统运行期间可能要用到的寄存器，如ALU算术逻辑在求和时，会将结果先送到数据暂存寄存器。

CPU的寄存器分为两类

1. 一类是对其内部使用的，对程序员不可见。“是否可见”不是说寄存器是否能看见，是指程序员能否使用。CPU内部由其自己的运行机制，是按照某个预定框架进行的，为了CPU能够运行下去，必然会有一些寄存器来做数据的支撑，给CPU内部的数据提供存储空间。这一部分对外是不可见的，我们无法使用它们，比如全局描述符表寄存器GDTR、中断描述表寄存器IDTR、局部……标志寄存器`flags`、调试寄存器`DR0~7`。

2. 另一类是对程序员可见的寄存器。我们进行汇编语言程序设计时，能够直接操作的就是这些寄存器，如段寄存器、通用寄存器等。

虽然第一类的程序是不可见寄存器，我们没法直接使用它们，但它们中的一部分还得由咱们给初始化。

比如全局描述符表寄存器`GDTR`，以后咱们还要通过`lgdt`指令为其制定全局描述符表的地址以及偏移量。

代码段和数据段都由可能在硬盘中，而栈段是在内存中。

像段寄存器SS那样只能用来放栈段基址，通用寄存器可以用来保存任何数据，包括地址。

实模式的“实”体现在：程序中用到的地址都是真实的物理地址，段基本址：段内偏移产生的逻辑地址就是物理地址，也就是程序员看到的完全是真实地内存。

x86 memory segmentation refers to the implementation of memory segmentation in the Intel x86 computer instruction set architecture. Segmentation was introduced on the Intel 8086 in 1978 as a way to allow programs to address more than 64 KB (65,536 bytes) of memory. 

In real mode, the segmentation architecture of the Intel 80286 and subsequent processors identifies memory locations with a 16-bit segment and a 16-bit offset, which is resolved into a physical address via (segment) x 16 + (offset). Although intended to address only 1 Megabyte (MB) (220 bytes) of memory, segment:offset addresses at FFFF:0010 and beyond reference memory beyond 1 MB (FFFF0 + 0010 = 100000). So this mode can actually address the first 65520 bytes of extended memory as part of the 64 KB range starting 16 bytes before the 1 MB mark—FFFF:0000 (0xFFFF0) to FFFF:FFFF (0x10FFEF). The Intel 8086 and Intel 8088 processors, with only 1 MB of memory and only 20 address lines, wrapped around at the 20th bit, so that address FFFF:0010 was equivalent to 0000:0000.[1]

如`0xFFFFF+2`，理论上是变成了`0x100001`。但由于只能容纳20位长地数据，所以最终结果是`0x00001`。这是地址回卷的结果，即超过最大范围之后，从0开始重新计数。回卷英文称为`wrap around`。

寻址方式，从大方向来看可以分为3类

1. 寄存器寻址
2. 立即数寻址
3. 内存寻址

在第三种内存寻址中又分为

1. 直接寻址
2. 基址寻址
3. 变址寻址
4. 基址变址寻址

寻址就是寻找地址，寻找谁的地址？CPU眼里只有二进制数，所以这是CPU在寻找“数”的地址。这个数可以是源操作数，也可以是目的操作数，简而言之，寻址就是找到“数”的所在地，从哪来，到哪去。

最直接的寻址方式就是寄存器寻址，它是指“数”在寄存器中，直接从寄存器中拿数据就可以了。

```
mov ax, 0x10
mov dx, 0x9
mov dx
```

以上三条指令都是寄存器寻址。

像这样也是立即数寻址
```
mov ax, macro_selector
mov ax, label_start
```
在编译阶段会转换为数字，最终可执行文件中依然是立即数。

CPU给程序员用的寄存器不是很多，所以操作数一多起来的时候，基本就倒腾不开了。内存空间就相对大很多，于是CPU工程师自然而然想到用内存来存储操作数。

由于访问内存是用“段基址：段内偏移地址”的形式，特别强调一下，此形式只用在内存访问中。默认情况下数据段寄存器是`DS`，即段基址已经有了，只要再给出段内偏移地址就可以访问内存了，最终起决定作用的、有效的是段内偏移地址，所以段内偏移地址称为有效地址。

直接寻址，就是将只再操作书中给出的数字作为内存地址，通过中括号的形式告诉CPU，取此地址中的值作为操作数，如：

```
mov ax, [0x1234]
mov ax, [fs:0x5678]
```

`0x1234`是段内偏移地址，默认的段地址是`DS`。这条指令是将内存地址`DS:0x1234`处的值写入`ax`寄存器。还记得规则吗？段基本址* 16变成20位地址后，再加上段内偏移地址`0x1234`，当然结果还是20位地址。

第二条指令中，最终的内存地址是`fs`寄存器的值*16 + 0x5678，CPU到此内存地址取值再存入`ax`寄存器。

基址寻址，就是在操作数中用`bx`或者`bp`寄存器作为地址的起始，地址的变化以它为基础。这里只能用`bx`或者`bp`作为基址寄存器，用寄存器作为内存地址，在实模式下是这样的。到了保护模式就没有这个限制了，可以是全部的通用寄存器。


bx寄存器的默认段寄存器是DS，而bp及其村的默认段寄存器是SS，即`bp`和`sp`都是栈的有效地址。如果你忘记了什么是有效地址，第`0`章有介绍，简而言之有效之际就是指偏移地址。例如`add word[bx], 0x1234`这条指令将`0x1234`加上内存地址`ds:bx`处的值之后再存入内存地址`ds:bx`中。这条指令用到了立即数寻址和内存基址寻址两种方式。

sp寄存器作为栈顶指针，相当于栈中数据的游标。这是给`push`和`pop`导航用的寄存器。

假如执行`push ax`

```
sub sp, 2 #先将sp的值减去
mov sp, ax #再将ax的值mov到新的sp指向的内存
```

是模式下的`pop`指令，其工作原理也分为两步，假如执行`pop ax`

```
mov ax, [sp] #先将sp指向的值mov到ax
add sp, 2 #再将sp的指针+2
```

下面通过这段代码了解堆栈框架的原理

```c
int a = 0;
function(int b, int c){
    int d;
}
a++;
```

调用`function(1, 2)`；按照C语言调用规范，参入入栈的顺序从右到左；会先压入`2`，再压入`1`，每个参数在栈中占用4字节。

2. 栈中再压入function的返回地址

此时`ebp`便是栈中局部变量的分界线。在这之后，`esp`将自减一定的值为局部变量在栈中分配空间。

`sub esp, 4`由于函数`function`中有局部变量`d`，局部变量是在栈中存放的，故`esp`要预留出4字节给变量`d`使用。

3. 终于到了应用`ebp`指针的时候，以`ebp`为基址对栈中数据寻址。

`[ebp-4]`是局部变量d
`[ebp]`是`ebp`在栈中的备份
`[ebp + 4]`是函数的返回地址

函数结束后跳过局部变量的空间：`mov esp, ebp`
恢复`ebp`的值，`pop ebp`。

堆栈框架的工作是为函数分配局部空间，因此应该在刚刚进入函数时就进行为局部变量分配空间的动作，离开函数时再回首局部变量的空间，所以堆栈框架的创建和回收工作分别是再进入函数和离开函数时进行的。为了再名称上突显这两个阶段，有一条指令叫做`ENTER`。他是再进入函数时执行的，其功能就是备份`ebp`并使`ebp`更新为`esp`，即先`push ebp`，即先`push ebp`再`mov ebp, esp`。另一条指令是`leave`，它是在离开函数时候执行的，其功能是回收局部变量的空间并恢复`ebp`的值。即先`mov esp, ebp`在`pop ebp`。
