bochs config
```
megs: 32
romimage: file=/usr/share/bochs/BIOS-bochs-latest
vgaromimage: file=/usr/share/vgabios/vgabios.bin

ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
ata0-master: type=disk, path="hd60M.img", mode=flat, cylinders=121, heads=16, spt=63


boot: disk

log: bochs.out
mouse: enabled=0
keyboard_mapping: enabled=1, map=x11-pc-us.map
```

create hard disk
```
bximage -hd -mode="flat" -size=60 -q hd60M.img
```

所谓载入内存，大概分为两部分：

1. 程序被加载器（软件或硬件）加载到某个硬件区域
2. CPU的cs:ip寄存器被指向这个程序的起始地址

BIOS的主要工作是检测、初始化硬件，怎么初始化？硬件自己提供了一些初始化的功能调用，BIOS直接调用就好了。BIOS还做了一件伟大的事情，建立了**中断向量表**。这样就可以通过”int 中断号“来实现相关的硬件调用，当然BIOS建立的这些功能就是对硬件的IO操作，也就是输入输出。但有时就64KB大小的空间，不可能把所有硬件的IO操作实现的面面俱到，而且也必要实现这么多，毕竟是在实模式下，对硬件支持的再丰富也是白搭，所以挑一些重要的、保证计算机能运行的那些硬件的基本操作，就行了。

地址总线宽度决定过了可以访问的内存空间的大小，如16位机的地址总线为20位，其地址范围是1MB，32位地址总线宽度是32位，其地址范围是4GB。但以上的地址范围指的是计算机在寻址上可以达到的疆域。可是人家并没有说要寻哪里，就拿16位机来说，并没有说这16位的寻址范围必须得是物理内存，难道人家的20位地址总线就得认这一亩三分地吗？完全不是。

归根结底的原因是这样的：在计算机中，并不是只有咱们插在主板上的内存条需要通过地址总线访问，某些地方给了显存，某些小地方给了硬盘控制器等。留够了之后，其余地方留给GUI。所有4GB的内存，在电脑里只显示3.8G

总之，表示地址的那串数字是地址总线的输入，相当于其参数，和内存条没关系。CPU能够访问一个地址，这是地址总线给做的映射，相当于给该地址分配了一个存储单元 ，二该存储单元要么落在某个外设的内存中，要么落在了物理内存条上。

在开机的一瞬间，也就是通电的一瞬间，CPU的`cs:ip`寄存器被强制初始化为`0xF000:0xFFF0`。由于开机的时候处于实模式，再重复一遍加深印象，在实模式下的段基址要乘以16，也就是左移4位，于是`0xF000:0xFFF0`的等效地址将是`0xFFFF0`。此地址就是`BIOS`的入口地址。

BIOS最后一项工作是检验启动盘中位于0盘0道1扇区的内容。如果此扇区末尾的两个字节分别是魔数`0x55`和`0xaa`，BIOS便认为此扇区确实存在可执行的程序（此程序便是MBR），便加载到物理地址`0x7c00`，随后跳转到此地址，继续执行。

$和$$是编译器NASM预留的关键字，用来表示当前行和本section的地址，起到了标号的作用，它是`nasm`提供的，并不是CPU原生支持的，相当于伪指令一样，对CPU是假的。

**伪指令**是编译器为了开发人员写代码方便而提供的一些符号，这些符号在编译时，会由编译器转换为CPU可识别的东西，如指令或地址等。如

```assembly
code_start:
  mov ax, 0
```

`code_start`这个标号被`nasm`认为是一个地址，此指令便是`mov ax, 0`这条指令所在的地址，即其机器指令机器码的存放的内存位置是`code_start`。`code_start`只是个标记，CPU并不认识，所以`nasm`会为其安排的地址来替换标号`code_start`，到了CPU手中，已经被替换成有意义的数字形式的地址了。

如果上面的例子改为

```assembly
code_start
    jmp $
```

$$指代本`section`的起始地址，此地址同样是编译器给安排的。

`section`也称为节、段，顾名思义，是程序中的一小段，形象一点说，就是用`section`这个关键字在程序中圈出一块地，并向编译器宣称，这块地我要做些规划，至于我要干些什么您就不用担心了，编译时请您合理安排。

比如一下代码

```assembly
section data
  var dd 0
section code
  jmp start
```

编译器一看这两个`section`，`data`中定义的是变量，`code`中是代码，于是把这两个`section`的内容分别归入最终的数据段和代码段。

有时候`nasm`并不会完全听您的，如改为下面的例子

```assembly
section data_a
  var dd 0
section code
  jmp start
section data_b
  var dd 1
```

随后人为定义了三个`section`，但`nasm`发现了`data_a`和`data_b`这两个`section`完全能够合并到一起，于是编译阶段会被合理的安排在一起。

`section`是伪指令，`CPU`运行程序是不需要这个东西的，这个只是给程序员规划程序用的。

`bin`是纯二进制。纯二进制就是不掺杂其他的东西，直接给CPU就能使用，也就是可执行文件中什么样，内存中就什么样。我们平时所说的`elf`或者`pe`格式的二进制可执行文件，那里面有好多和指令无关的东西，里面有很多程序的内存布局、位置等信息，这是给操作系统的程序加载器用的，是属于操作系统规划的范畴了。

```assembly
SECTION MBR vstart=0x7c00
    mov ax, cs
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov fs, ax
    mov sp,  0x7c00

    mov ax, 0x600
    mov bx, 0x700
    mov cx, 0
    mov dx, 0x184f

    int 0x10

    mov ah, 3
    mov bh, 0

    int 0x10

    mov ax, message
    mov bp, ax

    mov cx, 5
    mov ax, 0x1301

    mov bx, 0x2

    int 0x10

    jmp $

    message db "1 MBR"
    times 510-($-$$) db 0
    db 0x55, 0xaa
```
