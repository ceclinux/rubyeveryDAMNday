bochs config
```
megs: 32
romimage: file=/usr/share/bochs/BIOS-bochs-latest
vgaromimage: file=/usr/share/vgabios/vgabios.bin

ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
ata0-master: type=disk, path="hd60M.img", mode=flat, cylinders=121, heads=16, spt=63


boot: disk

log: bochs.out
mouse: enabled=0
keyboard_mapping: enabled=1, map=x11-pc-us.map
```

create hard disk
```
bximage -hd -mode="flat" -size=60 -q hd60M.img
```

所谓载入内存，大概分为两部分：

1. 程序被加载器（软件或硬件）加载到某个硬件区域
2. CPU的cs:ip寄存器被指向这个程序的起始地址

BIOS的主要工作是检测、初始化硬件，怎么初始化？硬件自己提供了一些初始化的功能调用，BIOS直接调用就好了。BIOS还做了一件伟大的事情，建立了**中断向量表**。这样就可以通过”int 中断号“来实现相关的硬件调用，当然BIOS建立的这些功能就是对硬件的IO操作，也就是输入输出。但有时就64KB大小的空间，不可能把所有硬件的IO操作实现的面面俱到，而且也必要实现这么多，毕竟是在实模式下，对硬件支持的再丰富也是白搭，所以挑一些重要的、保证计算机能运行的那些硬件的基本操作，就行了。

地址总线宽度决定过了可以访问的内存空间的大小，如16位机的地址总线为20位，其地址范围是1MB，32位地址总线宽度是32位，其地址范围是4GB。但以上的地址范围指的是计算机在寻址上可以达到的疆域。可是人家并没有说要寻哪里，就拿16位机来说，并没有说这16位的寻址范围必须得是物理内存，难道人家的20位地址总线就得认这一亩三分地吗？完全不是。

归根结底的原因是这样的：在计算机中，并不是只有咱们插在主板上的内存条需要通过地址总线访问，某些地方给了显存，某些小地方给了硬盘控制器等。留够了之后，其余地方留给GUI。所有4GB的内存，在电脑里只显示3.8G

总之，表示地址的那串数字是地址总线的输入，相当于其参数，和内存条没关系。CPU能够访问一个地址，这是地址总线给做的映射，相当于给该地址分配了一个存储单元 ，二该存储单元要么落在某个外设的内存中，要么落在了物理内存条上。

在开机的一瞬间，也就是通电的一瞬间，CPU的`cs:ip`寄存器被强制初始化为`0xF000:0xFFF0`。由于开机的时候处于实模式，再重复一遍加深印象，在实模式下的段基址要乘以16，也就是左移4位，于是`0xF000:0xFFF0`的等效地址将是`0xFFFF0`。此地址就是`BIOS`的入口地址。

BIOS最后一项工作是检验启动盘中位于0盘0道1扇区的内容。如果此扇区末尾的两个字节分别是魔数`0x55`和`0xaa`，BIOS便认为此扇区确实存在可执行的程序（此程序便是MBR），便加载到物理地址`0x7c00`，随后跳转到此地址，继续执行。

$和$$是编译器NASM预留的关键字，用来表示当前行和本section的地址，起到了标号的作用，它是`nasm`提供的，并不是CPU原生支持的，相当于伪指令一样，对CPU是假的。

**伪指令**是编译器为了开发人员写代码方便而提供的一些符号，这些符号在编译时，会由编译器转换为CPU可识别的东西，如指令或地址等。如

```assembly
code_start:
  mov ax, 0
```

`code_start`这个标号被`nasm`认为是一个地址，此指令便是`mov ax, 0`这条指令所在的地址，即其机器指令机器码的存放的内存位置是`code_start`。`code_start`只是个标记，CPU并不认识，所以`nasm`会为其安排的地址来替换标号`code_start`，到了CPU手中，已经被替换成有意义的数字形式的地址了。

如果上面的例子改为

```assembly
code_start
    jmp $
```

$$指代本`section`的起始地址，此地址同样是编译器给安排的。

`section`也称为节、段，顾名思义，是程序中的一小段，形象一点说，就是用`section`这个关键字在程序中圈出一块地，并向编译器宣称，这块地我要做些规划，至于我要干些什么您就不用担心了，编译时请您合理安排。

比如一下代码

```assembly
section data
  var dd 0
section code
  jmp start
```

编译器一看这两个`section`，`data`中定义的是变量，`code`中是代码，于是把这两个`section`的内容分别归入最终的数据段和代码段。

有时候`nasm`并不会完全听您的，如改为下面的例子

```assembly
section data_a
  var dd 0
section code
  jmp start
section data_b
  var dd 1
```

随后人为定义了三个`section`，但`nasm`发现了`data_a`和`data_b`这两个`section`完全能够合并到一起，于是编译阶段会被合理的安排在一起。

`section`是伪指令，`CPU`运行程序是不需要这个东西的，这个只是给程序员规划程序用的。

`bin`是纯二进制。纯二进制就是不掺杂其他的东西，直接给CPU就能使用，也就是可执行文件中什么样，内存中就什么样。我们平时所说的`elf`或者`pe`格式的二进制可执行文件，那里面有好多和指令无关的东西，里面有很多程序的内存布局、位置等信息，这是给操作系统的程序加载器用的，是属于操作系统规划的范畴了。

```assembly
SECTION MBR vstart=0x7c00
    mov ax, cs
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov fs, ax
    mov sp,  0x7c00

    mov ax, 0x600
    mov bx, 0x700
    mov cx, 0
    mov dx, 0x184f

    int 0x10

    mov ah, 3
    mov bh, 0

    int 0x10

    mov ax, message
    mov bp, ax

    mov cx, 5
    mov ax, 0x1301

    mov bx, 0x2

    int 0x10

    jmp $

    message db "1 MBR"
    times 510-($-$$) db 0
    db 0x55, 0xaa
```

`0x10`中断事最为强大的BIOS中断了，调用的方法是把功能号送入`ah`寄存器，随后执行`int 0x10`即可。

第三行的`vstart=0x7c00`表示本程序在编译时，告诉编译器，把我们的起始地址编译为`0x7c00`。

第4~8行是用`cs`寄存器的值去初始化其他寄存器。由于`BIOS`是通过
`jmp 0:0x7c00`跳转到mbr的，故`cs`此时为0，对于ds,es,fs,
gs这类的`sreg`，CPU不能直接给他们赋值，没有从立即数到段寄存器的电路实现，只有通过其他寄存器来中转，这里我们是通过`ax`来中转。

第9行是初始化栈指针，在CPU上运行的程序得遵从CPU的规则，`mbr`也是程序，是程序就要用到栈。目前`0x7c00`一下暂时是安全的区域，就把它当作栈来使用。

第`11-28`行是清屏。因为在`BIOS`中作中，会有一些输出，如检测硬件的结果信息。为了让大家看清楚我们在`MBR`中的输出字符串，故先把BIOS的输出清掉，这里演示
的是中断`0x10`的用法。

第`30-35`行是做打印前的工作，先获取光标的位置，目的是比秒打印字符的混乱，覆盖别人的输出。其实这个防君子不防小人的做法，万一别人不在光标处打印，自己打印的东西同样会被
别人覆盖。字符打印的位置，不一定要在光标处，字符的位置只和显存中的地址有关，和光标是没关系的，这只是人为的加了约束。

这里还用到了叶的概念，您看第33行，往`bh`寄存器中写入了0，这是告诉`BIOS`例程，我要获取第0页当前的光标，什么是页呢？

显示器有很多模式，如图形模式、文本模式等，在文本模式中，又可以工作于`80*25`和`40*25`等显示方式，默认情况下，所有个人计算机的显卡在加电后都将自己重置成`80*25`这种显示模式，由于一个字符要用两个字节表示，故显示一屏需要4000字节，这一屏就称为1夜，0页是默认页。

第38~52行是往光标处打印字符，说一下第48行的`mov ax, 0x1301`，13对应的是`ah`寄存器，这是调用`0x13`号子功能。`01`对应的是`al`寄存器，表示的是写字符的方式，al=1时，显示字符串，并且光标跟随到新位置。

`message db "1 MBR"`是定义打印的字符串。

第58行的`$$`是本`section`的起始地址，上面说过了`$`是本行所在的地址，故`$-$$`是本行到本`section`的偏移量。由于`mbr`的最后两个字节是固定的内容，分别是`0x55`和`0xaa`，要预留出两个字符，故扇区前`512-510`字节要填满，那到底呀多少字节才能填满次山区了。用510字节减去上面通过`$-$$`得到的偏移量。其结果就是本扇区的剩余量。由此可见第50行的`times 510-$($-$$) do 0`是在用0将本扇区的剩余空间填充。

```nasm
00000000 B80000 mov ax,0x0 
00000003 8ED8 mov ds,ax 
00000005 A10D00 mov ax,[0xd] 
00000008 B80800 mov ax,0x8 
0000000B EBFB jmp short 0x8 
0000000D 99 cwd 
0000000E 00 db 0x00
```

源码经编译之后都会变成我们不认识的东西，这个东西是机器码，还是数据，取决于源码中相应的内容。例如第二行`mov ds, ax`，明显是指令，被编译器处理之后，其所在地址出的内容就是机器码`8ED8`，长得完全不像是`mov ds, ax`。

而源码`var dw 0x99`，明显就是数据定义，查看内容列，它经编译之后，变成了99、00，因为`dw`是定义一个字，双字节，并且`x86`是小端字节序，低位的`99`在低地址，高位的`00`在高地址，所以`D`处内容是`99`，地址`E`处的内容是`00`。

`$$`表示所在的`section`的起始地址，由于这6行代码中没有定义`section`，故`nasm`默认把全体文件当成一个大的`section`。

第二行涉及真指令，不牵涉符号转换，所以反汇编后的代码同源码一致。

第三行引用了`var`变量的值，`[]`符号是取所在地址处的内容。在相应的反汇编代码中，相应的第三行中`var`这个符号地址被编译器替换成`0xd`。

第四行源码是`label: mov ax,$`，`label`是个符号，代表指令`mov ax, $`所在地址。`$`是个隐式的标号，表示当前地址。按理说这两个标号值应该是一致的，验证一下，查看下反汇编代码列的第四行，`$`被替换为`0x8`，即本行的`mov`指令地址是`0x8`。

顺便说一句，CPU不去判断给他的内容是指令，还是一般数据，他也分不清楚。CPU执行命令是顺序向下执行的，所以若没有第5行的`jmp`形成子循环，CPU执行到第六行时，会把`var`变量的值99当成指令，是否会报错还不得而知，这得看它得数是否恰好能成为个指令。这里就敲好能称为扩展指令CWD。

```nasm
section code
mov ax,$$
mov ax,section.data.start
mov ax,[var1]
mov ax,[var2]
label: jmp label

section data
var1 dd 0x4

var2 dw 0x99
```

```nasm
00000000  B80000            mov ax,0x0
00000003  B81000            mov ax,0x10
00000006  A11000            mov ax,[0x10]
00000009  A11400            mov ax,[0x14]
0000000C  EBFE              jmp short 0xc
0000000E  0000              add [bx+si],al
00000010  0400              add al,0x0
00000012  0000              add [bx+si],al
00000014  99                cwd
00000015  00                db 0x00
```

第1行和第8行为空，并没有产生相应地址或机器指令，这就是`section`为伪指令的原因。

第3行中用到了`section.data.start`，其用法是`section.节名.start`，这里是获得名为`data`的`section`在本文件中的正式偏移，即起始地址，是`nasm`提供的伪指令。查看“反汇编代码”列的第一行，编译后已经被替换为`0x10`，说明定义的数据`section`起始地址为`0x10`。可见，定义的`section`，其起始地址是从上一个数据的地址延续下来的。

由于`var1`是数据`section`的首个数据，其地址必然是和数据`section`一致。故对比下“源码”列和“反汇编代码”列的第四行，`var1`的地址确实被替换成`0x10`。

故关键字`section`并没有对程序中的地址产生任何影响。

