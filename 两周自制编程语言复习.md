## 解释器
解释器根据程序中的算法执行运算。简单来说，它是一种用于执行程序的软件。如果执行的程序由虚拟机器语言或类似机器语言的程序设计语言携程，这种软件也能称为虚拟机。

## 编译器
编译器能将某种语言写成的程序转换为另一种语言的程序。通常它会将原程序转换为机器语言程序。编译器转换程序的行为称为编译，转换前的程序称为源代码或源程序。如果编译器没有把源代码直接转换为机器语言，一般称为源代码转换器（`source code translator`)

程序设计语言提供了何种类型的语言处理器不一而论，一些具有解释器，另一些则会提供编译器。例如，尽管C语言也提供了编译器，但却很少使用。C语言通常直接通过编译器转换为机器语言执行。转换后得到的机器语言程序会暂时保存至某个文件，需要借助操作系统来执行。

有些语言混用解释器和编译器。通常，Java语言首先会通过编译器吧源代码转换为Java二进制代码，并将这种工序你的机器语言保存在文件中。之后，Java虚拟机的解释器将执行这段代码。

传统的下一的编译器将会以文件形式保存转换后的程序。因此，只要源程序没有变更，编译器就仅需执行一次，执行时间也会缩短。然后，一些编译器并不保存转换后的程序文件。这种编译器常见于解释器内部。

大多数Java虚拟机为了提高性能，会在执行过程中通过编译器将一部分Java二进制代码直接转换为机器语言使用。执行过程中进行的机器语言转换称为动态编译或JIT编译。转换后得到的机器语言程序将被载入内存，由硬件执行，无需使用解释器。

无论是解释器还是编译器，语言处理器前半部饭的程序结构都大同小异。源代码首先将进行词法分析，由一长串字符串细分为多个更小的字符串单元。分割后的字符串称为单词。之后处理器将执行语法分析处理，吧单词的排列转换为抽象语法树。**至此为止，解释器与编译器的处理方法相同。**之后，编译器将会把抽象语法树转换为其他语言，而解释器将会一边分析抽象语法树一边执行运算。

`x/ruby/3`该怎么理解，正则表达式字面量？除法？

通过上下文判断并不容易，实现起来也较为复杂，因此Stone语言就不支持这种语法了。

`dangling-else`问题是一个著名的二义语法。例如，Java语言允许下面的if语句。

```java
if (x > 0)
  if (y > 0)
    return x + y;
else
  return -x;
```

这段代码的问题在于判断`else`应当对应哪一个`if`。如果语法没有对此做出明确规定，两个`if`都美哟问题。Java语言当然做了规定，在这种情况下，`else`于最近的一个`if`对应，因此不存在起义（因此，上面代码中的缩进是不恰当的）。

语言处理器在词法分析阶段将程序分割为单词后，将开始构造抽象语法树。抽象语法树是一种用于表示程序结构的属性结构。构造抽象语法树的过程称为语法分析，依然属于园处理器的前半阶段。经过此法分析后，程序已经被凤姐为一个个单词。词法分析的主要任务是分析单词之间的关系，如判断哪些单词属于同一个表达式或语句，以及处理左右括号的配对问题。语法分析的结果能偶通过抽象语法树来表示。这一阶段还会检查程序中是否由语法错误。

抽象语法树仅用于表示语法分析的结果，因此通过词法分析得到的单词不一定要于抽象语法树的节点意义对应。抽象语法树是一种去除了多余信息的抽象树形结构。除了括号，句尾的分号等无关紧要的单词通常也不会出现在抽象语法树中。

BNF与上下文无关文法等价

语法规则中出现的终结符都是抽象语法树的叶节点。非终结符`term`和`factor`也是抽象语法树的节点。
